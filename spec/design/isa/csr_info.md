# CSR List
Control/Status Register and other privileged info for ISA.

ISA: RV64GC_Zicsr_Zifencei Sv39

## General Rules
- csr[11:0]
    - csr[11:10]
        - 00, 01, 10:
            - read/write
        - 11:
            - read-only
    - csr[9:8]
        - lowest executing privilege level that can access
        - 00:
            - User/Application
            - U-mode
        - 01:
            - Supervisor
            - S-mode
        - 10:
            - reserved
        - 11:
            - Machine
            - M-mode
- CSR's have associated privilege level where this privilege level and higher privilege levels can access it
    - raise illegal instruction exception if current privilege level not allowed to access CSR
- raise illegal instruciton exception if try to write to read-only register
    - writes to read-only fields of read/write registers are simply ignored
- dependent CSR's can affect the value of fields of other CSR's if a write to the CSR affects a dependent CSR's field
    - these value modifications do not cause CSR write side affects for the dependent CSR
- implicit CSR reads are equivalent in affect of explicit CSR reads
    - i.e. satp CSR modifications must propagate immediately
- unsupported CSR -> raise illegal instruction

### CSR Fields
- WPRI
    - Reserved Writes Preserve Values, Reads Ignore Values
    - SW's job to maintain value if not writing to field
    - if unused: read-only zero
- WLRL
    - Write/Read Only Legal Values
    - only have to support legal values
    - OPTIONAL: raise illegal-instruction exception if SW writes illegal value
    - always read legal values unless wrote illegal value previously
- WARL
    - Write Any Values, Read Legal Values
    - SW can test field to see legal values by trying to write value and see what gets read
    - no exceptions if illegal value
    - always read legal values unless wrote illegal value previously


## ISA CSR's
- ISA defined per-core Control/Status Registers
- listing all of the RISC-V standard M, S, and U mode CSR's, and explicitly vetoing the ones which are unsupported
    - H mode CSR's are also standard, but none of them are supported

### Machine CSR's
- M-mode-only accessible CSR's

#### Machine Info
- 0xF11: mvendorid
    - vendor ID
    - MRO
    - this one specifically 32-bit
    - {32'h0}
        - non-commercial implementation
- 0xF12: marchid
    - architecture ID
    - MRO
    - {64'h0}
        - need to ask RISC-V International if want ID
- 0xF13: mimpid
    - implementation ID
    - MRO
    - {64'h0}
        - don't care for me
- 0xF14: mhartid
    - hardware thread ID
    - MRO
    - assign by core:
        - core0: 64'h0
            - reset core must be 64'h0
        - core1: 64'h1
        - core2: 64'h2
        - core3: 64'h3
- 0xF15: mconfigptr
    - pointer to configuration data structure
    - MRO
    - used by OpenSBI
        - figure out what should be for this platform
    - can be MMCSR read
    - can be hardwired addr
    - can be read-only zero

#### Trap Setup
- 0x300: mstatus
    - machine status
    - MRW
    - {SD, WPRI[24:0], MBE, SBE, SXL[1:0], UXL[1:0], WPRI[8:0], TSR, TW, TVM, MXR, SUM, MPRV, XS[1:0], FS[1:0], MPP[1:0], VS[1:0], SPP, MPIE, UBE, SPIE, WPRI, MIE, WPRI, SIE, WPRI}
        - MIE, SIE: 
            - interrupt enables
            - MIE:
                - M-mode interrupt enable
                - enable interrupts when executing in M-mode
                - WARL
            - SIE:
                - S-mode interrupt enable
                - enable interrupts when executing in S-mode
                - WARL
            - regardless of these values, still never get interrupted by interrupts for lower privilege modes
                - M-mode execution cannot be interrupted by S-mode level interrupt
            - regardless of these value, can still get interrupted by interrupts for higher privilege modes
                - S-mode execution can always be interrupted by M-mode level interrupt
                - U-mode execution can always be interrupted by M-mode or S-mode level interrupts
        - MPIE, SPIE, MPP, SPP: 
            - previous interrupt enables and privilege modes
            - make up two-level privilege mode stack
                - two-level in that save current and previous mode info
                - SW must be careful to maintain this stack e.g. guarantee no exceptions while saving privilege mode stack
            - MPIE:
                - M-mode previous interrupt enable
                - MIE value before this trap
                    - SW can restore MIE to this MPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - SPIE:
                - S-mode previous interrupt enable
                - SIE value before this trap
                    - SW can restore SIE to this SPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - MPP[1:0]:
                - M-mode previous privilege mode
                - 00: previously U-mode
                - 01: previously S-mode
                - 10: reserved
                - 11: previously M-mode
                - WARL
            - SPP:
                - S-mode previous privilege mode
                - 0: previously U-mode
                - 1: previously S-mode
                - WARL
            - HW support:
                - trap to M-mode
                    - MPIE <= MIE
                    - MIE <= 1'b0
                    - MPP <= mode trapped from
                - trap to S-mode
                    - SPIE <= SIE
                    - SIE <= 1'b0
                    - SPP <= mode trapped from
                - MRET
                    - see [Trap Return](#trap-return)
                - SRET
                    - see [Trap Return](#trap-return)
        - MPRV:
            - Modify Privilege
            - MPRV = 0:
                - use executing privilege mode's DATA (load/store/amo) memory translation and protection rules
            - MPRV = 1:
                - use DATA (load/store/amo) memory translation and protection rules designated by the MPP privilege mode
            - WARL
            - essentially, SW can enable translation and protection for M-mode loads and stores
                - e.g. misaligned load, can directly use virtual address that S-mode or U-mode tried to access
            - MPRV = 0 guaranteed for U-mode and S-mode
            - MPRV = 0 OR MPRV = 1 for M-mode
        - MXR: 
            - Make Executable Readable
            - MXR = 0:
                - normal translation and protection rules where can only load from page with R=1
            - MXR = 1:
                - allow loads from pages with X=1 or R=1
            - WARL
            - implies MPRV = 1 for this field to be relevant, when trying to do a translated and protected load in M-mode
        - SUM:
            - permit Supervisor User Memory access
            - SUM = 0:
                - S-mode load/store accesses to U=1 pages will fault
            - SUM = 1:
                - S-mode load/store accesses to U=1 pages are permitted
            - WARL
            - implies translation and protection in effect for this field to have an effect
            - S-mode instruction execute access to U=1 pages always faults
            - relevant to M-mode when MPRV=1 & MPP=S-mode
                - this is when DATA memory accesses are effectively S-mode accesses
        - MBE, SBE, UBE:
            - byte endianness for DATA memory accesses
                - instruction accesses always little-endian
            - 0 for little endian, 1 for big endian
            - UBE = 1'b0:
                - U-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
            - SBE = 1'b0:
                - S-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
            - MBE = 1'b0:
                - M-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
        - TVM:
            - Trap Virtual Memory
            - TVM = 0:
                - satp CSR reads/writes and SFENCE.VMA allowed in S-mode
            - TVM = 1:
                - satp CSR reads/writes and SFENCE.VMA raise an illegal-instruction exception in S-mode 
            - WARL
        - TW:
            - Timeout Wait
            - TW = 0:
                - S-mode can freely execute WFI
            - TW = 1:
                - S-mode use of WFI either:
                    - waits for bounded time before completing
                    - gives illegal instruction
            - WARL
            - U-mode use of WFI always either:
                - waits for bounded time before completing
                - gives illegal instruction
            - simple: 
                - TW = 1 & S-mode immediately gives illegal instruction
                - U-mode WFI always immediately gives illegal instruction
        - TSR:
            - Trap SRET
            - TSR = 0:
                - SRET is permitted in S-mode
            - TSR = 1:
                - SRET in S-mode raises illegal-instruction exception
            - WARL
        - SXL, UXL:
            - SXL[1:0] = 2'b10:
                - SXLEN = 64
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
            - UXL[1:0] = 2'b10:
                - UXLEN = 64
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
        - FS, VS, XS, SD:
            - extension context status
                - 2 bits each for {Off, Initial, Clean, Dirty} states
            - FS[1:0]:
                - FPU state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - VS[1:0] = 2'b00:
                - Vector state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - XS[1:0] = 2'b00:
                - additional U-mode extension state encoding
                - WARL
                    - will ignore writes
            - SD:
                - SD = 0:
                    - none of FS, VS, XS dirty
                - SD = 1: 
                    - any of FS, VS, XS dirty
                - read-only
- 0x301: misa
    - ISA and extensions
    - MRW
    - {MXL[1:0], 36'h0, Extensions[25:0]}
        - MXL[1:0] = 2'b10
            - MXLEN = 64
            - WARL
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
        - Extensions[25:0] = 26'b00000101000001000100101101
            - Extensions A:Z
                - 0: A for Atomic
                - 2: C for Compressed
                - 3: D for Double-Precision FP
                - 5: F for Single-Precision FP
                - 8: I for RV64I
                - 12: M for Mul/Div
                - 18: S for Supervisor Mode
                - 20: U for User Mode
            - WARL
                - will ignore writes
                    - else would need to be able to dynamically change Extensions
- 0x302: medeleg
    - machine exception delegation
    - MRW
    - all exceptions trap to M-mode by default
    - set bits in medeleg, medelegh for corresponding exceptions to trap to S-mode when executing in S-mode or U-mode
        - corresponding exceptions executing in M-mode still trap to M-mode
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b0
    - HW support for delegated exception:
        - set scause
        - set sepc
        - set stval
        - set mstatus.SPP following execution mode when trapped
        - set mstatus.SIE = 0
    - HW support for all bits as writeable 0 or 1:
        - means HW support for any exception delegatable 
        - exceptions that aren't possible in lower privileged modes are read-only zero
            - medeleg[11] = 1'b0
- 0x303: mideleg
    - machine interrupt delegation
    - MRW
    - mostly same semantics as medeleg but for interrupts
    - delegated interrupts are ignored in M-mode
        - instead of interrupting to M-mode if executing in M-mode, these are now ignored
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b1
    - no midelegh
- 0x304: mie
    - machine interrupt enable
    - MRW
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b1
    - when interrupt into M-mode for interrupt i:
        - either:
            - executing in M-mode and mstatus.MIE = 1'b1
            - executing in S-mode OR U-mode
        - mip[i] = 1'b1 & mie[i] = 1'b1
        - mideleg[i] = 1'b0
    - propagate changes to mip, mie, mstatus, mideleg immediately on MRET, SRET, and dependent CSR writes
    - M-mode interrupts take priority over S-mode delegated interrupts
    - bits of supported interrupts can be written by CSR writes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIE, 1'b0, MEIE, 1'b0, SEIE, 1'b0, MTIE, 1'b0, STIE, 1'b0, MSIE, 1'b0, SSIE, 1'b0}
        - LCOFIE = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts
        - MEIE:
            - M External Interrupt Enable
        - MTIE:
            - M Timer Interrupt Enable
        - MSIE:
            - M Software Interrupt Enable
        - SEIE:
            - S External Interrupt Enable
        - STIE:
            - S Timer Interrupt Enable
        - SSIE:
            - S Software Interrupt Enable
- 0x305: mtvec
    - machine trap-vector base-address
    - MRW
    - {BASE[63:2], MODE[1:0]}
        - BASE:
            - base address of trap PC
            - give 4-byte aligned upper 62 PC bits
            - WARL
        - MODE:
            - trap vectorization enable
            - WARL
            - MODE = 2'b00: Direct
                - all exceptions and interrupts:
                    - PC <= BASE
            - MODE = 2'b01: Vectored
                - exceptions:
                    - PC <= BASE
                - interrupts:
                    - PC <= BASE + 4 * (interrupt cause)
            - MODE = 2'b10, 2'b11:
                - reserved
                - WARL so force to 2'b00 or 2'b01 if try to write these
- 0x306: mcounteren
    - machine counter enable
    - MRW
    - give access to aliased CSR reads for S-mode and U-mode using cycle, time, instret, and hpmcounter[i] U CSR's
    - this one specifically 32-bit
    - {HPM[31:3], IR, TM, CY}
        - CY:
            - CY = 0:
                - reads to cycle by S-mode or U-mode CSR instr gives illegal instr
            - CY = 1:
                - reads to cycle by S-mode CSR instr permitted
                - reads to cycle by U-mode CSR instr permitted if scounteren.CY = 1, else illegal instr
        - TM:
            - TM = 0:
                - reads to time by S-mode or U-mode CSR instr gives illegal instr
            - TM = 1:
                - reads to time by S-mode CSR instr permitted
                - reads to time by U-mode CSR instr permitted if scounteren.TM = 1, else illegal instr
        - IR:
            - IR = 0:
                - reads to instret by S-mode or U-mode CSR instr gives illegal instr
            - IR = 1:
                - reads to instret by S-mode CSR instr permitted
                - reads to instret by U-mode CSR instr permitted if scounteren.IR = 1, else illegal instr
        - HPM[31:3]:
            - HPM[i] = 0:
                - reads to hpmcounter[i] by S-mode or U-mode CSR instr gives illegal instr
            - HPM[i] = 1:
                - reads to hpmcounter[i] by S-mode CSR instr permitted
                - reads to hpmcounter[i] by U-mode CSR instr permitted if scounteren.HPM[i] = 1, else illegal instr

#### Trap Handling
- 0x340: mscratch
    - scrath register for machine trap handlers
    - MRW
        - just read/write reg
- 0x341: mepc
    - machine exception PC
    - MRW
    - {mepc[63:1], 1'b0}
        - HW sets mepc[63:1] with the PC of the instruction interrupted or the instruction that raised the exception on a trap to M-mode
        - SW can freely write mepc[63:1]
- 0x342: mcause
    - machine trap cause
    - MRW
    - {Interrupt, Exception Code[62:0]}
        - Interrupt:
            - if interrupt, HW sets Interrupt = 1'b1
            - if exception, HW sets Interrupt = 1'b0
        - Exception Code[62:0]:
            - HW sets corresponding Exception Code bit
                - seems like only set highest exception: i.e. one hot
                - also seems like must cleanly order an interrupt vs. an exception since can't report both same cycle
            - Interrupt = 1:
                - [0]: Reserved = 1'b0
                - [1]: S software interrupt
                - [2]: Reserved = 1'b0
                - [3]: M software interrupt
                - [4]: Reserved = 1'b0
                - [5]: S timer interrupt
                - [6]: Reserved = 1'b0
                - [7]: M timer interrupt
                - [8]: Reserved = 1'b0
                - [9]: S external interrupt
                - [10]: Reserved = 1'b0
                - [11]: M external interrupt
                - [12]: Reserved = 1'b0
                - [13]: Counter-overflow interrupt = 1'b0
                - [14:15]: Reserved = 2'b00
                - [16:63]: platform's choice = 48'h0
                    - none planned
                    - maybe [16] for power-on reset
            - Interrupt = 0:
                - [0]: instr addr misaligned = 1'b0
                    - IALIGN=16, so won't happen
                - [1]: instr access fault
                    - PMA (supported) or PMP (unsupported)
                - [2]: illegal instr
                - [3]: breakpoint
                    - EBREAK
                - [4]: load addr misaligned
                    - will only be for misaligned LR.W
                - [5]: load access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [6]: store/amo addr misaligned
                    - will only be for misaligned SC.W, AMO*
                - [7]: store/amo access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [8]: ECALL from U-mode
                - [9]: ECALL from S-mode
                - [10]: Reserved = 1'b0
                - [11]: ECALL from M-mode
                - [12]: instr page fault
                - [13]: load page fault
                    - includes LR.W
                - [14]: Reserved = 1'b0
                - [15]: store/amo page fault
                - [16:17]: Reserved = 2'b00
                - [18]: software check = 1'b0
                    - no extension present which would raise this
                        - e.g. for Spectre/Meltdown check
                - [19]: hardware error
                    - can use for unrecoverable fetch fault or other hardware bug detections
                - [20:23]: Reserved = 4'b0000
                - [24:31]: custom extensions = 8'h0
                - [32:47]: Reserved = 16'h0
                - [48:63]: custom extensions = 16'h0
        - exception priority
            - priority exists, see spec, not worth putting here
            - platform doesn't do fancy speculation that would ever raise exception in different priority order, so no need to enforce a specific priority
    - HW sets on trap into M-mode
- 0x343: mtval
    - machine bad address or instruction
    - MRW
    - HW sets on all traps to M-mode
        - bad address exceptions:
            - breakpoint, addr misaligned, PMA or PMP access fault, or page fault
            - set to virtual address
                - PC for bad fetch addr
                - load/store/amo address for bad dmem access 
                    - only have this after dtlb lookup and no later, wouldn't want to complete instr anyway, so give ldu/stamofu page fault immediately after dtlb lookup
        - illegal instr:
            - write zero-extended instruction
                - uncompressed should follow {32'h0, instr[31:0]}
                - compressed should follow {48'h0, instr[15:0]}
        - else: 
            - write 64'h0
    - SW can freely write
- 0x344: mip
    - machine interrupt pending
        - use this reg to give indication of existent interrupt
            - i.e. use these actual reg bits to determine if interrupt core
    - MRW
    - bit indexes correspond to mcause bit indexes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIE, 1'b0, MEIE, 1'b0, SEIE, 1'b0, MTIE, 1'b0, STIE, 1'b0, MSIE, 1'b0, SSIE, 1'b0}
        - LCOFIP = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts for mhpmevent[i] counters
        - MEIP:
            - M External Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by PLIC
        - MTIP:
            - M Timer Interrupt Pending
            - read-only by CSR instr's
            - set when (mtime > mtimecmp)
            - cleared by writing to mtimecmp such that (mtime < mtimecomp) 
            - see [Machine Timer Registers](#machine-timer-registers)
        - MSIP:
            - M Software Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by IPI MMCSR's
        - SEIP:
            - S External Interrupt Pending
            - written by M-mode SW to explicitly signal external interrupt for S-mode
            - PLIC can also signal the existence of a pending S external interrupt
                - this doesn't write SEIP bit
                - exists independently but used for reads
            - CSR read's follow SEIP bit OR PLIC signal
                - this fancy behavior only for SEIP
                    - supposedly for mimicking external interrupts
        - STIP:
            - S Timer Interrupt Pending
            - writable by CSR instr's so M-mode can signal timer interrupt to S-mode
        - SSIP:
            - S Software Interrupt Pending
            - writable by CSR instr's
                - M-mode can signal to S-mode 
            - also set and cleared by IPI MMCSR's
    - priority:
        - MEI > MSI > MTI > SEI > SSI > STI > LCOFI
    - see mie ^ for remaining semantics
- 0x34A: mtinst
    - machine trap instruction (transformed)
    - MRW
    - H extension unsupported, illegal instr
- 0x34B: mtval2
    - machine bad guest physical address
    - MRW
    - H extension unsupported, illegal instr
    
#### Config
- 0x30A: menvcfg
    - machine environment config
    - MRW
    - {STCE, PBMTE, ADUE, CDE, WPRI[25:0], PMM[1:0], WPRI[23:0], CBZE, CBCFE, CBIE[1:0], WPRI[2:0], FIOM}
        - FIOM:
            - Fence of I/O implies Memory for S-mode and U-mode
            - decoder OR's io + mem aq's and rl's for FENCE's
                - already treating mem and io together for AMO aq's, rl's
        - PBMTE = 1'b0:
            - Svpbmt extension for RV64I page attributes unsupported
        - ADUE = 1'b0:
            - Svadu extension for SW PTE A/D bit updates unsupported
        - CDE = 1'b0:
            - Smcdeleg extension for counter delegation to S-mode unsupported
        - STCE = 1'b0:
            - unratified Sstc extension unsupported
        - CBZE = 1'b0:
            - unratified Zicboz extension unsupported
        - {CBCFE, CBIE[1:0]} = 3'b000:
            - unratified Zicbom extension unsupported
        - PMM = 1'b0:
            - unratified Smnpm extension unsupported
    - all read-only zero
- 0x747: mseccfg
    - machine security config
    - MRW
    - unsupported, illegal instr

#### Memory Protection
- 0x3A0:0x3AF: pmpcfg0:15
    - PMP config's
    - MRW
    - unsupported, illegal instr
- 0x3B0:0x3EF: pmpaddr0:63
    - PMP addr's
    - MRW
    - unsupported, illegal instr

#### State Enable
- 0x30C:0x30F: mstateen0:3
    - machine state enables
    - MRW
    - for Smstateen extension
    - unsupported, illegal instr
- 0x31C:0x31F: mstateen0h:3h
    - upper 32 bits of mstateen[i]
    - MRW
    - for Smstateen extension
    - unsupported, illegal instr

#### Non-Maskable Interrupt Handling
- 0x740: mnscratch
    - NMI scratch reg
    - MRW
    - NMI's unsupported, illegal instr
- 0x741: mnepc
    - NMI PC
    - MRW
    - NMI's unsupported, illegal instr
- 0x742: mncause
    - NMI cause
    - MRW
    - NMI's unsupported, illegal instr
- 0x744: mnstatus
    - NMI status
    - MRW
    - NMI's unsupported, illegal instr

#### Counters, Timers
- 0xB00: mcycle
    - machine cycle 64-bit counter
    - MRW
    - can write to give new value to continue counting from
- 0xB02: minstret
    - machine instructions retired 64-bit counter
    - instructions retired since arbitrary time in past
    - MRW
    - can write to give new value to continue counting from
    - don't increment for instructions causing synchronous exceptions
        - ECALL, EBREAK, illegal instr, etc.
- 0xB03:0xB1F: mhpmcounter3:31
    - machine perf monitoring 64-bit counters
    - MRW
    - can write to give new value to continue counting from
    - platform-specific and ideally local to core for routing concerns
        - instrs dispatched
        - alu reg retired
        - alu imm retired
        - bru retired
        - mdu retired
        - ldu retired
        - store retired
        - amo retired
        - fence retired
        - sys retired
        - icache accesses
        - icache misses
        - itlb accesses
        - itlb misses
        - dcache accesses
        - dcache misses
        - dtlb accesses
        - dtlb misses
        - L2 cache accesses
        - L2 cache misses

#### Counter Setup
- 0x320: mcountinhibit
    - machine counter inhibit
    - MRW
    - prevent increment of associated counter
    - this one specifically 32-bit
    - {HPM[31:3], IR, 1'b0, CY}
        - CY:
            - CY = 0:
                - prevent increment of cycle
            - CY = 1:
                - cycle increment normally
        - IR:
            - IR = 0:
                - prevent increment of minstret
            - IR = 1:
                - minstret increment normally
        - HPM[31:3]:
            - HPM[i] = 0:
                - prevent increment of mhpmcounter[i]
            - HPM[i] = 1:
                - hpmcounter[i] increment normally
- 0x323:0x33F: mhpmevent3:31
    - machine perf monitoring event selector
    - MRW
    - platform-specific
        - likely not worth it to define more than 29 counters, so event selects wouldn't be used
            - especially since can use partial fields in the counters
        - if do select, CSR's essentially treated as indirect reg's
        - TBD, but likely make all read-only hardwired value

#### Debug/Trace
- 0x7A0: tselect
    - debug/trace trigger select
    - MRW
    - unratified, illegal instr
- 0x7A1: tdata1
    - debug/trace trigger data 1
    - MRW
    - unratified, illegal instr
- 0x7A2: tdata2
    - debug/trace trigger data 2
    - MRW
    - unratified, illegal instr
- 0x7A3: tdata3
    - debug/trace trigger data 3
    - MRW
    - unratified, illegal instr
- 0x7A8: mcontext
    - machine context
    - MRW
    - unratified, illegal instr

#### Debug Mode
- 0x7B0: dcsr
    - debug control and status
    - DRW
    - unratified, illegal instr
- 0x7B1: dpc
    - debug PC
    - DRW
    - unratified, illegal instr
- 0x7B2: dscratch0
    - debug scratch reg 0
    - DRW
    - unratified, illegal instr
- 0x7B3: dscratch1
    - debug scratch reg 1
    - DRW
    - unratified, illegal instr


### Supervisor CSR's
- many of these are aliased subsets of machine-mode CSR's

#### Trap Setup
- 0x100: sstatus
    - supervisor status
    - SRW
    - aliased subset of mstatus
    - {SD, WPRI[28:0], UXL[1:0], WPRI[11:0], MXR, SUM, WPRI, XS[1:0], FS[1:0], WPRI[1:0], VS[1:0], SPP, WPRI, UBE, SPIE, WPRI[3:0], SIE, WPRI}
        - SIE:
            - S-mode interrupt enable
            - enable interrupts when executing in S-mode
            - WARL
            - regardless of value, can still get interrupted by interrupts for higher privilege modes
                - S-mode execution can always be interrupted by M-mode level interrupt
                - U-mode execution can always be interrupted by M-mode or S-mode level interrupts
        - SPIE, SPP:
            - previous interrupt enable and privilege mode
            - make up two-level privilege mode stack
                - two-level in that save current and previous mode info
                - SW must be careful to maintain this stack e.g. guarantee no exceptions while saving privilege mode stack
            - SPIE:
                - S-mode previous interrupt enable
                - SIE value before this trap
                    - SW can restore SIE to this SPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - SPP:
                - S-mode previous privilege mode
                - 0: previously U-mode
                - 1: previously S-mode
                - WARL
            - HW support:
                - trap to S-mode
                    - SPIE <= SIE
                    - SIE <= 1'b0
                    - SPP <= mode trapped from
                - SRET
                    - see [Trap Return](#trap-return)
        - MXR:
            - Make Executable Readable
            - MXR = 0:
                - normal translation and protection rules where can only load from page with R=1
            - MXR = 1:
                - allow loads from pages with X=1 or R=1
            - WARL
        - SUM:
            - permit Supervisor User Memory access
            - SUM = 0:
                - S-mode load/store accesses to U=1 pages will fault
            - SUM = 1:
                - S-mode load/store accesses to U=1 pages are permitted
            - WARL
            - implies translation and protection in effect for this field to have an effect
            - S-mode instruction execute access to U=1 pages always faults
        - UBE:
            - byte endianness for DATA memory accesses
                - instruction accesses always little-endian
            - 0 for little endian, 1 for big endian
            - UBE = 1'b0:
                - U-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
        - FS, VS, XS, SD:
            - extension context status
                - 2 bits each for {Off, Initial, Clean, Dirty} states
            - FS[1:0]:
                - FPU state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - VS[1:0] = 2'b00:
                - Vector state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - XS[1:0] = 2'b00:
                - additional U-mode extension state encoding
                - WARL
                    - will ignore writes
            - SD:
                - SD = 0:
                    - none of FS, VS, XS dirty
                - SD = 1: 
                    - any of FS, VS, XS dirty
                - read-only
        - UXL:
            - UXL[1:0] = 2'b10:
                - UXLEN = 64
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
- 0x104: sie
    - supervisor interrupt-enable
    - SRW
    - aliased subset of mstatus
        - mie and mip have diff bits for M vs. S mode versions of interrupts, of which sie and sip can RW the S-mode versions
    - bit indexes correspond to scause bit indexes
        - following Interrupt = 1'b1
    - when interrupt into S-mode for interrupt i:
        - either:
            - executing in S-mode and sstatus.SIE = 1'b1
            - executing in U-mode
        - sip[i] = 1'b1 & sie[i] = 1'b1
        - mideleg[i] = 1'b1?
            - spec doesn't mention but seems to be implied, else would have interrupted into M-mode
    - propagate changes to sip, sie, sstatus immediately on SRET and dependent CSR writes
    - bits of supported interrupts can be written by CSR writes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIE, 3'b000, SEIE, 3'b000, STIE, 3'b000, SSIE, 1'b0}
        - LCOFIE = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts
        - SEIE:
            - S External Interrupt Enable
        - STIE:
            - S Timer Interrupt Enable
        - SSIE:
            - S Software Interrupt Enable
- 0x105: stvec
    - supervisor trap handler base address
    - SRW
    - separate from mtvec
        - need to jump to different places for M-mode traps vs. S-mode traps
        - also, S-mode using virtual memory, M-mode using baremetal
    - {BASE[63:2], MODE[1:0]}
        - BASE:
            - base address of trap PC
            - give 4-byte aligned upper 30 PC bits
            - WARL
        - MODE:
            - trap vectorization enable
            - WARL
            - MODE = 2'b00: Direct
                - all exceptions and interrupts:
                    - PC <= BASE
            - MODE = 2'b01: Vectored
                - exceptions:
                    - PC <= BASE
                - interrupts:
                    - PC <= BASE + 4 * (interrupt cause)
            - MODE = 2'b10, 2'b11:
                - reserved
                - WARL so force to 2'b00 or 2'b01 if try to write these
- 0x106: scounteren
    - supervisor counter enable
    - SRW
    - separate from mcounteren
        - this is separate control to also check for allowing access in U-mode
    - give access to aliased CSR reads for U-mode using time, instret, and hpmcounter[i] U CSR's
    - this one specifically 32-bit
    - {HPM[31:3], IR, TM, CY}
        - CY:
            - CY = 0:
                - reads to cycle by U-mode CSR instr gives illegal instr
            - CY = 1:
                - reads to cycle by U-mode CSR instr permitted if mcounteren.CY = 1, else illegal instr
        - TM:
            - TM = 0:
                - reads to time by U-mode CSR instr gives illegal instr
            - TM = 1:
                - reads to time by U-mode CSR instr permitted if mcounteren.TM = 1, else illegal instr
        - IR:
            - IR = 0:
                - reads to instret by U-mode CSR instr gives illegal instr
            - IR = 1:
                - reads to instret by U-mode CSR instr permitted if mcounteren.IR = 1, else illegal instr
        - HPM[31:3]:
            - HPM[i] = 0:
                - reads to hpmcounter[i] by U-mode CSR instr gives illegal instr
            - HPM[i] = 1:
                - reads to hpmcounter[i] by U-mode CSR instr permitted if mcounteren.HPM[i] = 1, else illegal instr
    - for S-mode, CSR read allowed if mcounteren.\<counter\>
    - for U-mode, CSR read allowed if mcounteren.\<counter\> & scounteren.\<counter\>

#### Config
- 0x10A: senvcfg
    - supervisor environment config
    - SRW
    - no senvcfgh
    - {WPRI[29:0], PMM[1:0], WPRI[23:0], CBZE, CBCFE, CBIE[1:0], WPRI[2:0], FIOM}
        - FIOM:
            - Fence of I/O implies Memory for U-mode
            - decoder OR's io + mem aq's and rl's for FENCE's
                - already treating mem and io together for AMO aq's, rl's
        - CBZE = 1'b0:
            - unratified Zicboz extension unsupported
        - {CBCFE, CBIE[1:0]} = 3'b000:
            - unratified Zicbom extension unsupported
        - PMM = 2'b00:
            - unratified Smnpm extension unsupported

#### Counter Setup
- 0x120: scountinhibit
    - supervisor counter-inhibit
    - SRW
    - unsupported
        - used by Smcdeleg Extension for counter delegation

#### Trap Handling
- 0x140: sscratch
    - scratch register for supervisor trap handlers
    - SRW
        - just read/write reg
    - separate from mscratch
        - for S mode purposes
    - typically used to store pointer to hart-local suprvisor context while hart executing in U
- 0x141: sepc
    - supervisor exception PC
    - SRW
    - separate from mepc
        - want separate exception information per execution mode
    - {sepc[63:1], 1'b0}
        - HW sets sepc[63:1] with the PC of the instruction interrupted or the instruction that raised the exception on a trap to S-mode
        - SW can freely write sepc[63:1]
- 0x142: scause
    - supervisor trap cause
    - SRW
    - separate from mcause
        - want separate exception information per execution mode
        - scause supports subset of non-M-mode bits in mcause, but should be separate hardware so that S-mode can track its own exception information
    - {Interrupt, Exception Code[62:0]}
        - Interrupt:
            - if interrupt, HW sets Interrupt = 1'b1
            - if exception, HW sets Interrupt = 1'b0
        - Exception Code[30:0]:
            - HW sets corresponding Exception Code bit
                - seems like only set highest exception: i.e. one hot
                - also seems like must cleanly order an interrupt vs. an exception since can't report both same cycle
            - Interrupt = 1:
                - [0]: Reserved = 1'b0
                - [1]: S software interrupt
                - [4:2]: Reserved = 3'b000
                - [5]: S timer interrupt
                - [8:6]: Reserved = 3'b000
                - [9]: S external interrupt
                - [12:10]: Reserved = 3'b000
                - [13]: Counter-overflow interrupt = 1'b0
                    - unsupported
                - [14:15]: Reserved = 2'b00
                - [16:63]: platform's choice = 48'h0
                    - none planned
                    - maybe [16] for power-on reset
            - Interrupt = 0:
                - [0]: instr addr misaligned = 1'b0
                    - IALIGN=16, so won't happen
                - [1]: instr access fault
                    - PMA (supported) or PMP (unsupported)
                - [2]: illegal instr
                - [3]: breakpoint
                    - EBREAK
                - [4]: load addr misaligned
                    - need for LR.W misaligned
                - [5]: load access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [6]: store/amo addr misaligned
                    - need for SC.W, AMO*.W misaligned
                - [7]: store/amo access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [8]: ECALL from U-mode
                - [9]: ECALL from S-mode
                - [11:10]: Reserved = 2'b00
                - [12]: instr page fault
                - [13]: load page fault
                    - includes LR.W
                - [14]: Reserved = 1'b0
                - [15]: store/amo page fault
                - [16:17]: Reserved = 2'b00
                - [18]: software check = 1'b0
                    - no extension present which would raise this
                        - e.g. for Spectre/Meltdown check
                - [19]: hardware error
                    - can use for unrecoverable fetch fault or other hardware bug detections
                - [20:23]: Reserved = 4'b0000
                - [24:31]: custom extensions = 8'h0
                - [32:47]: Reserved = 16'h0
                - [48:63]: custom extensions = 16'h0
    - HW sets on trap into S-mode
- 0x143: stval
    - supervisor bad address or instruction
    - SRW
    - HW sets on all traps to S-mode
        - bad address exceptions:
            - breakpoint, addr misaligned, PMA or PMP access fault, or page fault
            - set to virtual address
                - PC for bad fetch addr
                - load/store/amo address for bad dmem access 
                    - only have this after dtlb lookup and no later, wouldn't want to complete instr anyway, so give ldu/stamofu page fault immediately after dtlb lookup
        - illegal instr:
            - write zero-extended instruction
                - uncompressed should follow {32'h0, instr[31:0]}
                - compressed should follow {48'h0, instr[15:0]}
        - else: 
            - write 64'h0
    - SW can freely write
- 0x144: sip
    - supervisor interrupt pending
        - use this reg to give indication of existent interrupt
            - i.e. use these actual reg bits to determine if interrupt core
    - SRW
    - aliased subset of mstatus
        - mie and mip have diff bits for M vs. S mode versions of interrupts, of which sie and sip can RW the S-mode versions
    - bit indexes correspond to scause bit indexes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIP, 3'b000, SEIP, 3'b000, STIP, 3'b000, SSIP, 1'b0}
        - LCOFIP = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts for mhpmevent[i] counters
        - SEIP:
            - S External Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by PLIC
        - STIP:
            - S Timer Interrupt Pending
            - read-only by CSR instr's
                - M-mode will get MTIP trap, take care of timer details, then write STIP with CSR instr so S mode can get timer interrupt
        - SSIP:
            - S Software Interrupt Pending
            - writable by CSR instr's
                - probably so S-mode can clear self since S mode will not be touching IPI MMCSR's
                - self S-mode signal also possible since can set as well
            - also set by IPI MMCSR's
                - not cleared since that's M-mode's job to use IPI MMCSR's?
    - priority:
        - SEI > SSI > STI > LCOFI
    - see sie ^ for remaining semantics
- 0xDA0: scountovf
    - supervisor count overflow
    - unsupported
    - would be used for Sscofpmf extension for counter overflow diagnostics

#### VM
- 0x180: satp
    - supervisor address translation and protection
    - SRW
    - unique to S-mode
        - no M-mode copy nor alias
    - PTBR + ASID
    - {MODE[3:0], ASID[15:0], PPN[43:0]}
        - MODE:
            - MODE = 4'b0000:
                - "Bare" mode
                - PA = VA
                    - zero-extended
                - SW's job to write rest of reg to 0's
                - HW ignores rest of reg
            - MODE = 4'b1000:
                - "Sv39" mode
                - VM enabled
            - relevant when satp "active" -> executing in S-mode or U-mode
        - ASID:
            - Address Space ID
            - full WARL
        - PPN:
            - PPN of page table for this context
            - essentially PTBR
            - full WARL
    - satp updates don't perform any ordering or synchronization of page table updates
        - this is SFENCE.VMA's job
        - not strictly necessary on some context switches, and as such SFENCE.VMA can be skipped, so performance will improve


#### Debug/Trace
- 0x5A8: scontext
    - supervisor context
    - SRW
    - unratified, illegal instr

#### State Enable
- 0x10C:0x10F: sstateen0:3
    - supervisor state enables
    - SRW
    - for Smstateen extension
    - unsupported, illegal instr


### User CSR's

#### FPU
- 0x001: fflags
    - FPU accrued exceptions
    - URW
- 0x002: frm
    - FPU dynamic rounding mode
    - URW
- 0x003: fcsr
    - FPU control and status register
        - superset of equivalent bits when read fflags, frm individually
    - URW

#### Counters, Timers
- 0xC00: cycle
    - user cycle counter
    - cycles since arbitrary time in past
    - URO
    - alias to mcycle
- 0xC01: time
    - user time
    - real time since arbitrary time in past
    - tick at reasonable rate
        - when implement real time clock, probably some multiple of seconds or milliseconds or microseconds
    - URO
    - alias to read of mtime MMCSR
- 0xC02: instret
    - user instructions retired
    - instructions retired since arbitrary time in past
    - URO
    - don't increment for instructions causing synchronous exceptions
        - ECALL, EBREAK, illegal instr, etc.
    - alias to minstret
- 0xC03:0xC1F: hpmcounter3:31
    - perf monitoring counters
    - URO
    - alias to mhpmcounter3:31


## MMCSR's
- memory-mapped CSR's
- platform defined

### Machine MMCSR's
- machine-level memory-mapped CSR's 

#### Machine Timer Registers
- mtime
    - 64-bit timer
        - since RV32I, use 2x reads
    - RW
        - SW can reset value
        - HW, timer module only determines count-up
- mtimecmp
    - 64-bit timer compare
    - give Machine Timer Interrupt when (mtime > mtimecmp)
    - clear Machine Timer Interrupt when (mtime < mtimecomp) 
    - RW
        - SW can reset value
        - SW's job to set lower 32b and upper 32b such that don't get spurious interrupt while changing the value

#### Inter-Processor Interrupt Registers
- TODO


## Privileged Instructions

### Environment Call and Breakpoint
- ECALL
    - in U-mode: raise environment-call-from-U-mode exception
    - in S-mode: raise environment-call-from-S-mode exception
    - in M-mode: raise environment-call-from-M-mode exception
    - if exception delegated to S-mode:
        - set sepc with address of ECALL
    - if exception to M-mode:
        - set mepc with address of ECALL
- EBREAK, C.EBREAK
    - raise breakpoint exception
    - if exception delegated to S-mode:
        - set sepc with address of ECALL
    - if exception to M-mode:
        - set mpec with address of ECALL

### Trap Return
- MRET
    - pop M-mode privilege stack
        - set execution mode <= MPP
        - set MIE <= MPIE
        - set MPIE <= 1'b1
        - set MPP <= 2'b00 (U-mode)
        - set MPRV <= 1'b0 if MPP != 2'b11 (M-mode)
    - set PC <= mepc
    - permitted in M-mode
- SRET
    - pop S-mode privilege stack
        - set execution mode <= SPP
        - set SIE <= SPIE
        - set SPIE <= 1'b1
        - set SPP <= 1'b0 (U-mode)
        - set MPRV <= 1'b0
    - set PC <= sepc
    - permitted in M-mode 
    - permitted in S-mode if mstatus.TSR = 0

### Wait for Interrupt
- WFI
    - permitted in M-mode
    - permitted in S-mode if mstatus.TW = 0
    - permitted in S-mode but with HW time limit if mstatus.TW = 1
    - permitted in U-mode but with HW time limit
    - can use to signal to PLIC that this hart prime for external interrupts
    - WFI wakeup ignores mstatus.MIE, mstatus.SIE, always resuming execution after the WFI even if an interrupt won't be taken due to enable's being off for this mode
        - allows spooky in-current-code interrupt handling as opposed to trap jump
    - WFI wakeup ignores mideleg settings, always resuming execution after the WFI even if the interrupt wouldn't be taken in M-mode
    - WFI wakeup doesn't occur if the individual interrupt is not enabled via mie
        - allows mie to be true mask over mip functionality
    - if take interrupt, set mpec <= pc + 4, instr after WFI


## Excepting Instructions
- what CSR's to set
- PC following mtvec/stvec


## Interrupts
- what CSR's to set
- PC following mtvec/stvec


## Reset Functionality
- start execution in M-mode
- mstatus
    - mstatus.MIE <= 0
    - mstatus.MPRV <= 0
    - hardwired vals good-to-go
- misa
    - hardwired vals good-to-go
- inv reservation set
- PC <= platform-defined reset
- mcause
    - give reset condition
    - can use platform-specific conditions (e.g. interrupt=1, [16:30] causes)
    - can be 32'h0 for no special interpretation of reset
- everything else undefined, seems like just choose logical reset val
    - WARL's must be legal value


## Sv32 Paging
- Sv39 Mode
    - satp.MODE = 4'b1000
    - use paging in S-mode or U-mode
        - never use paging in M-mode, M-mode always acts like Bare Mode
    - 39b VA -> 56b PA
    - 27b VPN -> 44b PPN
    - 12b PO = 12b PO
- Bare Mode
    - satp.MODE = 4'b0000
    - no paging in any modes
    - 39b VA -> 56b PA = {17'h0, 32b VA}
    - 27b VPN -> 44b PPN = {17'h0, 27b VPN}
    - 12b PO = 12b PO
- satp.PPN is PPN of root page table
    - PTBR

### Sv32 Virtual Address
- 39-bit VA
- {VPN2[8:0], VPN1[8:0], VPN0[8:0], PO[11:0]}
    - VPN2:
        - root level 2 VPN
            - use VPN2 to access root level 2 PTE PA
                - {satp.PPN (PTBR), VPN2 * 8}
        - 9b for 2^9 * 8B = 2^12 B = 4KB root page table
    - VPN1:
        - root level 1 VPN
            - use VPN1 to access level 1 PTE PA
                - {level 2 PTE.PPN1, level 2 PTE.PPN0, VPN1 * 8}
        - 9b for 2^9 * 8B = 2^12 B = 4KB level 1 page table
    - VPN0:
        - leaf level 0 VPN
            - use VPN0 to access leaf level 0 PTE PA
                - {level 1 PTE.PPN1, level 1 PTE.PPN0, VPN0 * 8}
        - 9b for 2^9 * 8B = 2^12 B = 4KB level 0 page table
    - PO:
        - Page Offset
        - 12b for 2^12 B = 4KB page
    - essentially, when using 64-bit value as 39-bit VA, ignore upper 25 bits
        - can be used by SW for various purposes
        - for access concerns, HW ignores

### Sv32 Physical Address
- 56-bit PA
- {PPN2[25:0], PPN1[8:0], PPN0[8:0], PO[11:0]}
    - PPN2:
        - for PA for root level 2 PTE: satp.PPN[43:18] / satp.PPN2
        - for PA of level 1 PTE: root level 2 PTE.PPN2
        - for PA of level 0 PTE: level 1 PTE.PPN2
        - for PA of VA:
            - 1GB ultrapage: root level 2 PTE.PPN2
            - 2MB superpage: level 1 PTE.PPN2
            - 4KB page: level 0 PTE.PPN2
        - for PA of Bare VA: {17'h0, VA.VPN2}
    - PPN1:
        - for PA of root level 2 PTE: satp.PPN[17:9] / satp.PPN1
        - for PA of level 1 PTE: root level 2 PTE.PPN1
        - for PA of level 0 PTE: level 1 PTE.PPN1
        - for PA of VA: level 0 PTE.PPN1
            - 1GB ultrapage: VA.VPN1
            - 2MB superpage: level 1 PTE.PPN1
            - 4KB page: level 0 PTE.PPN0
        - for PA of Bare VA: VA.VPN1
    - PPN0:
        - for PA of root level 2 PTE: satp.PPN[8:0] / satp.PPN0
        - for PA of level 1 PTE: root level 2 PTE.PPN0
        - for PA of level 0 PTE: level 1 PTE.PPN0
        - for PA of VA:
            - 1GB ultrapage: VA.VPN0
            - 2MB superpage: VA.VPN0
            - 4KB page: level 0 PTE.PPN0
        - for PA of Bare VA: VA.VPN0
    - PO:
        - Page Offset
        - 12b for 2^12 B = 4KB page
        - for PA of root level 2 PTE: {VA.VPN2, 3'b000}
        - for PA of level 1 PTE: {VA.VPN1, 3'b000}
        - for PA of level 0 PTE: {VA.VPN0, 3'b000}
        - for PA of VA: VA.PO
        - for PA of Bare VA: VA.PO
- accessing root level 2 PTE:
    - PPN2 = satp.PPN[43:18] / satp.PPN2
    - PPN1 = satp.PPN[17:9] / satp.PPN1
    - PPN0 = satp.PPN[8:0] / satp.PPN0
    - PO = {VA.VPN2, 3'b000}
- accessing level 1 PTE:
    - PPN2 = root level 2 PTE.PPN2
    - PPN1 = root level 2 PTE.PPN1
    - PPN0 = root level 2 PTE.PPN0
    - PO = {VA.VPN1, 3'b000}
- accessing level 0 PTE:
    - PPN2 = level 1 PTE.PPN2
    - PPN1 = level 1 PTE.PPN1
    - PPN0 = level 1 PTE.PPN0
    - PO = {VA.VPN0, 3'b000}
- VA -> PA:
    - 1GB ultrapage:
        - PPN2 = root level 2 PTE.PPN2
        - PPN1 = VA.VPN1
        - PPN0 = VA.VPN0
        - PO = VA.PO
    - 2MB superpage:
        - PPN2 = level 1 PTE.PPN2
        - PPN1 = level 1 PTE.PPN1
        - PPN0 = VA.VPN0
        - PO = VA.PO
    - 4KB page:
        - PPN2 = level 0 PTE.PPN2
        - PPN1 = level 0 PTE.PPN1
        - PPN0 = level 0 PTE.PPN0
        - PO = VA.PO
- Bare VA -> PA:
    - PPN2 = {17'h0, VA.VPN2}
        - ignore upper bits of VA after VPN2
    - PPN1 = VA.VPN1
    - PPN0 = VA.VPN0
    - PO = VA.PO

### Sv32 Page Table Entry
- 64b = 8B PTE
- {N, PBMT[1:0], Reserved[6:0], PPN2[25:0], PPN1[8:0], PPN0[8:0], RSW[1:0], D, A, G, U, X, W, R, V}
    - V: valid
        - true valid when V = 1
        - all other bits don't cares if V = 0
        - if access PTE with V = 0, page fault
    - X, W, R:
        - X: execute permissions
            - can fetch instructions from page
            - can also load or LR.W from page if m/sstatus.MXR = 1
        - W: write permissions
            - can store, SC.W, or AMO to page
        - R: read permissions
            - can load or LR.W from page
        - case (X, W, R):
            - 000: pointer to next level of page table
                - page fault if already at level 0 leaf
            - 001: read-only
            - 010: reserved -> page fault
            - 011: read-write
            - 100: execute-only
            - 101: read-execute
            - 110: reserved -> page fault
            - 111: read-write-execute
        - if get leaf page at level 1, have superpage
            - must have PPN0 == 0, else misaligned superpage, page fault
        - page fault if perform memory access and don't have required permissions
    - U:
        - U-mode accessible
        - only relevant for leaf pages
        - U = 1:
            - U-mode can access
            - if sstatus.SUM = 1, S-mode can access
        - U = 0:
            - U-mode cannot access
            - S-mode can access
    - G:
        - Global mapping
        - mapping true for all ASID's
        - if non-leaf PTE is G, all leaves under this are G
        - can share TLB entry between ASID's
        - don't have to flush G TLB entries on SFENCE.VMA if rs2 doesn't pick x0, so only targetting ASID instead of all
    - A, D:
        - A: 
            - Accessed
            - set on instruction fetch, data read, or data write
                - sets for fetches and reads can be speculative
        - D: 
            - Dirty
            - set on write
        - only relevant for leaf pages
        - updates to these must be ordered before the access causing the update
            - TLB miss until update is visible
        - functionality requirements:
            - updates must be performed as coherent writes
            - ideally don't need to snoop into TLB's and page table walkers, as these already have software synchronization via SFENCE.VMA
        - idea: full MMU coherence
            - gets performance benefit of sharing TLB capacity among cores if there is sharing
            - means MMU caches must be inclusive and follow 64B cache block granularity
                - RIP if have page table sparsity
            - may get functionality issues with untimely TLB updates not controlled by SFENCE.VMA
            real issue: need to access TLB using physical address -> would have to be associative access -> yuck
        - idea: BusInv + BusWB
            - MMU performs BusInv to invalidate any copies of PTE in coherent memory
            - MMU performs masked BusWB to write new PTE value to coherent memory (so essentially at L3)
            - issue: if PTE entry currently in other core's MMU, then the update would be missed. if the first update is A & D, and the second update is A & !D, then the second update will ruin the first
                - racey fix: broadcast PTE entry update to other MMU's
                - maybe amazing fix: only perform bit set's at L3 for PTE update BusWB
                    - already has to be unique since not at block granularity
            - issue: coherent memory could have a new value
                - would be doing BusUpgrade/BusInv when it is possible coherent memory has the block in M. maybe unsupported case for bus. would need to grab M block value and RMW A/D bit set
        - idea: L2$ BusRdX
            - spec makes it seem like PTE A/D update must be fully coherent (due to atomic check for update of value at PTE when try to set A/D), so it needs coherent memory value of the PTE. if a new value is found, the translation process is even restarted given the updated PTE
                - this seems like a little much
                - just need atomic A/D sets and should be good to go
            - MMU gives read exclusive request to L2$ just like dcache would on a store
                - L2$ in E/M already, snoop dcache if in dcache, then good to go
                - otherwise, L2$ performs a BusRdX and gets the coherent block in M state
            - perform A/D set for block in L2$
                - don't clear any bits in case didn't have up-to-date PTE, only set
            - when done, TLB can be unblocked and allow access causing A/D set to complete
                - iTLB would be blocked unless this process was interrupted
                - dTLB could move on but acts as a dTLB miss for the load or store of interest until returns
            - actually, rules are that A can be speculatively accessed, D must be accurate and ordered before write
                - can freely updated A asynchronously on TLB access
                    - prolly won't have issue with ordering since much before commit
                - can update D on commit
                    - this is tricky to do in itself as have TLB info during TLB access much before commit
                    - can create D buffer of waiting PTE D updates
                        - allocate D buffer entry OR coalesce with counter in older D buffer entry on TLB access of mem write where see PTE.D = 0
                        - upon d$ wr_buf enq, clear allocated D buffer entry or decrement coalesced counter if killed, else perform 
                        - D buffer enq is tagged by PPN, and does coalescing of same PPN
                        - D buffer deq and update does associative search checking for allocated PPN
                        - add backpressure at TLB access if D buffer full
                        - can modify stmaofu_cq and add new interface signals to give relevant info for killed vs. unkilled D buffer check
                    - D buffer downsides
                        - can't get misaligned component if killed as-is right now
                            - would have to manually check PPN + 1 at same time unless want to add backpressure -> yuck
                        - also would need a very very big D buffer, essentially as big as the stamofu_cq since theoretically all entries could have PTE.D = 0
                            - big buffer which has to hold VPN (so know which PTE to update) and PPN (so core can communicate which one updated)
                    - can fix associative PPN check by using separate D buffer tags which core has to track
                        - D buffer only has to hold VPN for relevant 
                        - still nasty adding bunch of stamofu_cq/mq entry info
                        - still need to change stamofu_cq/mq deq process to give misaligned component D buffer tag along with central component on killed accesses
                - can just update D asynchronously on TLB access
                    - will be speculative but whatever, not the most massive deal in the world if page marked dirty by accident
                    - prolly will be ordered before store/amo commit
                    - not worth dealing with nastiness of D buffer to wait for commit
        - idea: send req to AMO unit and move one
            - coherence naturally handled by AMO unit functionality
            - technically page table entry update not ordered with access since move on
            - can't really just move on though as need to update PTE in TLB to prevent repeated sending of AMO's
                - no that's stupid -> just write back the updated A/D into the PTE in the TLB before the AMO finishes
            - not really that different from L2$ BusRdX
                - just a matter of if want to make bunch of new L2$ functionality or try to make AMO unit to also deal with TLB updates
        - idea: L2TLB miss always BusRdX
            - all L2TLB accesses always do BusRdx so can immediately speculatively set the Accessed bit on all PTE reads
                - obviously should do this as would have to just replicate the behavior in both the iTLB and dTLB anyway
                - minimal if any performance loss even with high PTE sharing because TLB entries not invalidated on BusRdX, only L2$ blocks
                    - worst case can get PTE cache block via a snoop into other L2$ if need them again
            - just a matter of choosing how to deal with Dirty bit
    - RSW = 2'b00
        - reserved
    - Reserved = 7'b0000000
        - reserved
    - PBMT = 2'b00
        - for Svpbmt extension
        - unsupported
    - N = 1'b0
        - for Svnapot extension
        - unsupported