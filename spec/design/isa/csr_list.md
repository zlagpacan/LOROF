# CSR List
Control/Status Register List for ISA: RV64GC_Zicsr_Zifencei Sv39

## General Rules
- csr[11:0]
    - csr[11:10]
        - 00, 01, 10:
            - read/write
        - 11:
            - read-only
    - csr[9:8]
        - lowest executing privilege level that can access
        - 00:
            - User/Application
            - U-mode
        - 01:
            - Supervisor
            - S-mode
        - 10:
            - reserved
        - 11:
            - Machine
            - M-mode
- CSR's have associated privilege level where this privilege level and higher privilege levels can access it
    - raise illegal instruction exception if current privilege level not allowed to access CSR
- raise illegal instruciton exception if try to write to read-only register
    - writes to read-only fields of read/write registers are simply ignored
- dependent CSR's can affect the value of fields of other CSR's if a write to the CSR affects a dependent CSR's field
    - these value modifications do not cause CSR write side affects for the dependent CSR
- implicit CSR reads are equivalent in affect of explicit CSR reads
    - i.e. satp CSR modifications must propagate immediately
- unsupported CSR -> raise illegal instruction

### CSR Fields
- WPRI
    - Reserved Writes Preserve Values, Reads Ignore Values
    - SW's job to maintain value if not writing to field
    - if unused: read-only zero
- WLRL
    - Write/Read Only Legal Values
    - only have to support legal values
    - OPTIONAL: raise illegal-instruction exception if SW writes illegal value
    - always read legal values unless wrote illegal value previously
- WARL
    - Write Any Values, Read Legal Values
    - SW can test field to see legal values by trying to write value and see what gets read
    - no exceptions if illegal value
    - always read legal values unless wrote illegal value previously


## ISA CSR's
- ISA defined per-core Control/Status Registers
- listing all of the RISC-V standard M, S, and U mode CSR's, and explicitly vetoing the ones which are unsupported
    - H mode CSR's are also standard, but none of them are supported

### Machine CSR's
- M-mode-only accessible CSR's

#### Machine Info
- 0xF11: mvendorid
    - vendor ID
    - MRO
    - this one specifically 32-bit
    - {32'h0}
        - non-commercial implementation
- 0xF12: marchid
    - architecture ID
    - MRO
    - {64'h0}
        - need to ask RISC-V International if want ID
- 0xF13: mimpid
    - implementation ID
    - MRO
    - {64'h0}
        - don't care for me
- 0xF14: mhartid
    - hardware thread ID
    - MRO
    - assign by core:
        - core0: 64'h0
            - reset core must be 64'h0
        - core1: 64'h1
        - core2: 64'h2
        - core3: 64'h3
- 0xF15: mconfigptr
    - pointer to configuration data structure
    - MRO
    - used by OpenSBI
        - figure out what should be for this platform
    - can be MMCSR read
    - can be hardwired addr
    - can be read-only zero

#### Trap Setup
- 0x300: mstatus
    - machine status
    - MRW
    - {SD, WPRI[24:0], MBE, SBE, SXL[1:0], UXL[1:0], WPRI[8:0], TSR, TW, TVM, MXR, SUM, MPRV, XS[1:0], FS[1:0], MPP[1:0], VS[1:0], SPP, MPIE, UBE, SPIE, WPRI, MIE, WPRI, SIE, WPRI}
        - MIE, SIE: 
            - interrupt enables
            - MIE:
                - M-mode interrupt enable
                - enable interrupts when executing in M-mode
                - WARL
            - SIE:
                - S-mode interrupt enable
                - enable interrupts when executing in S-mode
                - WARL
            - regardless of these values, still never get interrupted by interrupts for lower privilege modes
                - M-mode execution cannot be interrupted by S-mode level interrupt
            - regardless of these value, can still get interrupted by interrupts for higher privilege modes
                - S-mode execution can always be interrupted by M-mode level interrupt
                - U-mode execution can always be interrupted by M-mode or S-mode level interrupts
        - MPIE, SPIE, MPP, SPP: 
            - previous interrupt enables and privilege modes
            - make up two-level privilege mode stack
                - two-level in that save current and previous mode info
                - SW must be careful to maintain this stack e.g. guarantee no exceptions while saving privilege mode stack
            - MPIE:
                - M-mode previous interrupt enable
                - MIE value before this trap
                    - SW can restore MIE to this MPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - SPIE:
                - S-mode previous interrupt enable
                - SIE value before this trap
                    - SW can restore SIE to this SPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - MPP[1:0]:
                - M-mode previous privilege mode
                - 00: previously U-mode
                - 01: previously S-mode
                - 10: reserved
                - 11: previously M-mode
                - WARL
            - SPP:
                - S-mode previous privilege mode
                - 0: previously U-mode
                - 1: previously S-mode
                - WARL
            - HW support:
                - trap to M-mode
                    - MPIE <= MIE
                    - MIE <= 1'b0
                    - MPP <= mode trapped from
                - trap to S-mode
                    - SPIE <= SIE
                    - SIE <= 1'b0
                    - SPP <= mode trapped from
                - MRET
                    - see [Trap Return](#trap-return)
                - SRET
                    - see [Trap Return](#trap-return)
        - MPRV:
            - Modify Privilege
            - MPRV = 0:
                - use executing privilege mode's DATA (load/store/amo) memory translation and protection rules
            - MPRV = 1:
                - use DATA (load/store/amo) memory translation and protection rules designated by the MPP privilege mode
            - WARL
            - essentially, SW can enable translation and protection for M-mode loads and stores
                - e.g. misaligned load, can directly use virtual address that S-mode or U-mode tried to access
            - MPRV = 0 guaranteed for U-mode and S-mode
            - MPRV = 0 OR MPRV = 1 for M-mode
        - MXR: 
            - Make Executable Readable
            - MXR = 0:
                - normal translation and protection rules where can only load from page with R=1
            - MXR = 1:
                - allow loads from pages with X=1 or R=1
            - WARL
            - implies MPRV = 1 for this field to be relevant, when trying to do a translated and protected load in M-mode
        - SUM:
            - permit Supervisor User Memory access
            - SUM = 0:
                - S-mode load/store accesses to U=1 pages will fault
            - SUM = 1:
                - S-mode load/store accesses to U=1 pages are permitted
            - WARL
            - implies translation and protection in effect for this field to have an effect
            - S-mode instruction execute access to U=1 pages always faults
            - relevant to M-mode when MPRV=1 & MPP=S-mode
                - this is when DATA memory accesses are effectively S-mode accesses
        - MBE, SBE, UBE:
            - byte endianness for DATA memory accesses
                - instruction accesses always little-endian
            - 0 for little endian, 1 for big endian
            - UBE = 1'b0:
                - U-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
            - SBE = 1'b0:
                - S-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
            - MBE = 1'b0:
                - M-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
        - TVM:
            - Trap Virtual Memory
            - TVM = 0:
                - satp CSR reads/writes and SFENCE.VMA allowed in S-mode
            - TVM = 1:
                - satp CSR reads/writes and SFENCE.VMA raise an illegal-instruction exception in S-mode 
            - WARL
        - TW:
            - Timeout Wait
            - TW = 0:
                - S-mode can freely execute WFI
            - TW = 1:
                - S-mode use of WFI either:
                    - waits for bounded time before completing
                    - gives illegal instruction
            - WARL
            - U-mode use of WFI always either:
                - waits for bounded time before completing
                - gives illegal instruction
            - simple: 
                - TW = 1 & S-mode immediately gives illegal instruction
                - U-mode WFI always immediately gives illegal instruction
        - TSR:
            - Trap SRET
            - TSR = 0:
                - SRET is permitted in S-mode
            - TSR = 1:
                - SRET in S-mode raises illegal-instruction exception
            - WARL
        - SXL, UXL:
            - SXL[1:0] = 2'b10:
                - SXLEN = 64
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
            - UXL[1:0] = 2'b10:
                - UXLEN = 64
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
        - FS, VS, XS, SD:
            - extension context status
                - 2 bits each for {Off, Initial, Clean, Dirty} states
            - FS[1:0]:
                - FPU state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - VS[1:0] = 2'b00:
                - Vector state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - XS[1:0] = 2'b00:
                - additional U-mode extension state encoding
                - WARL
                    - will ignore writes
            - SD:
                - SD = 0:
                    - none of FS, VS, XS dirty
                - SD = 1: 
                    - any of FS, VS, XS dirty
                - read-only
- 0x301: misa
    - ISA and extensions
    - MRW
    - {MXL[1:0], 36'h0, Extensions[25:0]}
        - MXL[1:0] = 2'b10
            - MXLEN = 64
            - WARL
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
        - Extensions[25:0] = 26'b00000101000001000100101101
            - Extensions A:Z
                - 0: A for Atomic
                - 2: C for Compressed
                - 3: D for Double-Precision FP
                - 5: F for Single-Precision FP
                - 8: I for RV64I
                - 12: M for Mul/Div
                - 18: S for Supervisor Mode
                - 20: U for User Mode
            - WARL
                - will ignore writes
                    - else would need to be able to dynamically change Extensions
- 0x302: medeleg
    - machine exception delegation
    - MRW
    - all exceptions trap to M-mode by default
    - set bits in medeleg, medelegh for corresponding exceptions to trap to S-mode when executing in S-mode or U-mode
        - corresponding exceptions executing in M-mode still trap to M-mode
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b0
    - HW support for delegated exception:
        - set scause
        - set sepc
        - set stval
        - set mstatus.SPP following execution mode when trapped
        - set mstatus.SIE = 0
    - HW support for all bits as writeable 0 or 1:
        - means HW support for any exception delegatable 
        - exceptions that aren't possible in lower privileged modes are read-only zero
            - medeleg[11] = 1'b0
- 0x303: mideleg
    - machine interrupt delegation
    - MRW
    - mostly same semantics as medeleg but for interrupts
    - delegated interrupts are ignored in M-mode
        - instead of interrupting to M-mode if executing in M-mode, these are now ignored
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b1
    - no midelegh
- 0x304: mie
    - machine interrupt enable
    - MRW
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b1
    - when interrupt into M-mode for interrupt i:
        - either:
            - executing in M-mode and mstatus.MIE = 1'b1
            - executing in S-mode OR U-mode
        - mip[i] = 1'b1 & mie[i] = 1'b1
        - mideleg[i] = 1'b0
    - propagate changes to mip, mie, mstatus, mideleg immediately on MRET, SRET, and dependent CSR writes
    - M-mode interrupts take priority over S-mode delegated interrupts
    - bits of supported interrupts can be written by CSR writes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIE, 1'b0, MEIE, 1'b0, SEIE, 1'b0, MTIE, 1'b0, STIE, 1'b0, MSIE, 1'b0, SSIE, 1'b0}
        - LCOFIE = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts
        - MEIE:
            - M External Interrupt Enable
        - MTIE:
            - M Timer Interrupt Enable
        - MSIE:
            - M Software Interrupt Enable
        - SEIE:
            - S External Interrupt Enable
        - STIE:
            - S Timer Interrupt Enable
        - SSIE:
            - S Software Interrupt Enable
- 0x305: mtvec
    - machine trap-vector base-address
    - MRW
    - {BASE[63:2], MODE[1:0]}
        - BASE:
            - base address of trap PC
            - give 4-byte aligned upper 62 PC bits
            - WARL
        - MODE:
            - trap vectorization enable
            - WARL
            - MODE = 2'b00: Direct
                - all exceptions and interrupts:
                    - PC <= BASE
            - MODE = 2'b01: Vectored
                - exceptions:
                    - PC <= BASE
                - interrupts:
                    - PC <= BASE + 4 * (interrupt cause)
            - MODE = 2'b10, 2'b11:
                - reserved
                - WARL so force to 2'b00 or 2'b01 if try to write these
- 0x306: mcounteren
    - machine counter enable
    - MRW
    - give access to aliased CSR reads for S-mode and U-mode using cycle, time, instret, and hpmcounter[i] U CSR's
    - this one specifically 32-bit
    - {HPM[31:3], IR, TM, CY}
        - CY:
            - CY = 0:
                - reads to cycle by S-mode or U-mode CSR instr gives illegal instr
            - CY = 1:
                - reads to cycle by S-mode CSR instr permitted
                - reads to cycle by U-mode CSR instr permitted if scounteren.CY = 1, else illegal instr
        - TM:
            - TM = 0:
                - reads to time by S-mode or U-mode CSR instr gives illegal instr
            - TM = 1:
                - reads to time by S-mode CSR instr permitted
                - reads to time by U-mode CSR instr permitted if scounteren.TM = 1, else illegal instr
        - IR:
            - IR = 0:
                - reads to instret by S-mode or U-mode CSR instr gives illegal instr
            - IR = 1:
                - reads to instret by S-mode CSR instr permitted
                - reads to instret by U-mode CSR instr permitted if scounteren.IR = 1, else illegal instr
        - HPM[31:3]:
            - HPM[i] = 0:
                - reads to hpmcounter[i] by S-mode or U-mode CSR instr gives illegal instr
            - HPM[i] = 1:
                - reads to hpmcounter[i] by S-mode CSR instr permitted
                - reads to hpmcounter[i] by U-mode CSR instr permitted if scounteren.HPM[i] = 1, else illegal instr

#### Trap Handling
- 0x340: mscratch
    - scrath register for machine trap handlers
    - MRW
        - just read/write reg
- 0x341: mepc
    - machine exception PC
    - MRW
    - {mepc[63:1], 1'b0}
        - HW sets mepc[63:1] with the PC of the instruction interrupted or the instruction that raised the exception on a trap to M-mode
        - SW can freely write mepc[63:1]
- 0x342: mcause
    - machine trap cause
    - MRW
    - {Interrupt, Exception Code[62:0]}
        - Interrupt:
            - if interrupt, HW sets Interrupt = 1'b1
            - if exception, HW sets Interrupt = 1'b0
        - Exception Code[62:0]:
            - HW sets corresponding Exception Code bit
                - seems like only set highest exception: i.e. one hot
                - also seems like must cleanly order an interrupt vs. an exception since can't report both same cycle
            - Interrupt = 1:
                - [0]: Reserved = 1'b0
                - [1]: S software interrupt
                - [2]: Reserved = 1'b0
                - [3]: M software interrupt
                - [4]: Reserved = 1'b0
                - [5]: S timer interrupt
                - [6]: Reserved = 1'b0
                - [7]: M timer interrupt
                - [8]: Reserved = 1'b0
                - [9]: S external interrupt
                - [10]: Reserved = 1'b0
                - [11]: M external interrupt
                - [12]: Reserved = 1'b0
                - [13]: Counter-overflow interrupt = 1'b0
                - [14:15]: Reserved = 2'b00
                - [16:63]: platform's choice = 48'h0
                    - none planned
                    - maybe [16] for power-on reset
            - Interrupt = 0:
                - [0]: instr addr misaligned = 1'b0
                    - IALIGN=16, so won't happen
                - [1]: instr access fault
                    - PMA (supported) or PMP (unsupported)
                - [2]: illegal instr
                - [3]: breakpoint
                    - EBREAK
                - [4]: load addr misaligned
                    - will only be for misaligned LR.W
                - [5]: load access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [6]: store/amo addr misaligned
                    - will only be for misaligned SC.W, AMO*
                - [7]: store/amo access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [8]: ECALL from U-mode
                - [9]: ECALL from S-mode
                - [10]: Reserved = 1'b0
                - [11]: ECALL from M-mode
                - [12]: instr page fault
                - [13]: load page fault
                    - includes LR.W
                - [14]: Reserved = 1'b0
                - [15]: store/amo page fault
                - [16:17]: Reserved = 2'b00
                - [18]: software check = 1'b0
                    - no extension present which would raise this
                        - e.g. for Spectre/Meltdown check
                - [19]: hardware error
                    - can use for unrecoverable fetch fault or other hardware bug detections
                - [20:23]: Reserved = 4'b0000
                - [24:31]: custom extensions = 8'h0
                - [32:47]: Reserved = 16'h0
                - [48:63]: custom extensions = 16'h0
        - exception priority
            - priority exists, see spec, not worth putting here
            - platform doesn't do fancy speculation that would ever raise exception in different priority order, so no need to enforce a specific priority
    - HW sets on trap into M-mode
- 0x343: mtval
    - machine bad address or instruction
    - MRW
    - HW sets on all traps to M-mode
        - bad address exceptions:
            - breakpoint, addr misaligned, PMA or PMP access fault, or page fault
            - set to virtual address
                - PC for bad fetch addr
                - load/store/amo address for bad dmem access 
                    - only have this after dtlb lookup and no later, wouldn't want to complete instr anyway, so give ldu/stamofu page fault immediately after dtlb lookup
        - illegal instr:
            - write zero-extended instruction
                - uncompressed should follow {32'h0, instr[31:0]}
                - compressed should follow {48'h0, instr[15:0]}
        - else: 
            - write 64'h0
    - SW can freely write
- 0x344: mip
    - machine interrupt pending
        - use this reg to give indication of existent interrupt
            - i.e. use these actual reg bits to determine if interrupt core
    - MRW
    - bit indexes correspond to mcause bit indexes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIE, 1'b0, MEIE, 1'b0, SEIE, 1'b0, MTIE, 1'b0, STIE, 1'b0, MSIE, 1'b0, SSIE, 1'b0}
        - LCOFIP = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts for mhpmevent[i] counters
        - MEIP:
            - M External Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by PLIC
        - MTIP:
            - M Timer Interrupt Pending
            - read-only by CSR instr's
            - set when (mtime > mtimecmp)
            - cleared by writing to mtimecmp such that (mtime < mtimecomp) 
            - see [Machine Timer Registers](#machine-timer-registers)
        - MSIP:
            - M Software Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by IPI MMCSR's
        - SEIP:
            - S External Interrupt Pending
            - written by M-mode SW to explicitly signal external interrupt for S-mode
            - PLIC can also signal the existence of a pending S external interrupt
                - this doesn't write SEIP bit
                - exists independently but used for reads
            - CSR read's follow SEIP bit OR PLIC signal
                - this fancy behavior only for SEIP
                    - supposedly for mimicking external interrupts
        - STIP:
            - S Timer Interrupt Pending
            - writable by CSR instr's so M-mode can signal timer interrupt to S-mode
        - SSIP:
            - S Software Interrupt Pending
            - writable by CSR instr's
                - M-mode can signal to S-mode 
            - also set and cleared by IPI MMCSR's
    - priority:
        - MEI > MSI > MTI > SEI > SSI > STI > LCOFI
    - see mie ^ for remaining semantics
- 0x34A: mtinst
    - machine trap instruction (transformed)
    - MRW
    - H extension unsupported, illegal instr
- 0x34B: mtval2
    - machine bad guest physical address
    - MRW
    - H extension unsupported, illegal instr
    
#### Config
- 0x30A: menvcfg
    - machine environment config
    - MRW
    - {STCE, PBMTE, ADUE, CDE, WPRI[25:0], PMM[1:0], WPRI[23:0], CBZE, CBCFE, CBIE[1:0], WPRI[2:0], FIOM}
        - FIOM:
            - Fence of I/O implies Memory for S-mode and U-mode
            - decoder OR's io + mem aq's and rl's for FENCE's
                - already treating mem and io together for AMO aq's, rl's
        - PBMTE = 1'b0:
            - Svpbmt extension for RV64I page attributes unsupported
        - ADUE = 1'b0:
            - Svadu extension for SW PTE A/D bit updates unsupported
        - CDE = 1'b0:
            - Smcdeleg extension for counter delegation to S-mode unsupported
        - STCE = 1'b0:
            - unratified Sstc extension unsupported
        - CBZE = 1'b0:
            - unratified Zicboz extension unsupported
        - {CBCFE, CBIE[1:0]} = 3'b000:
            - unratified Zicbom extension unsupported
        - PMM = 1'b0:
            - unratified Smnpm extension unsupported
    - only control FIOM, else read-only zero
- 0x747: mseccfg
    - machine security config
    - MRW
    - unsupported, illegal instr

#### Memory Protection
- 0x3A0:0x3AF: pmpcfg0:15
    - PMP config's
    - MRW
    - unsupported, illegal instr
- 0x3B0:0x3EF: pmpaddr0:63
    - PMP addr's
    - MRW
    - unsupported, illegal instr

#### State Enable
- 0x30C:0x30F: mstateen0:3
    - machine state enables
    - MRW
    - for Smstateen extension
    - unsupported, illegal instr
- 0x31C:0x31F: mstateen0h:3h
    - upper 32 bits of mstateen[i]
    - MRW
    - for Smstateen extension
    - unsupported, illegal instr

#### Non-Maskable Interrupt Handling
- 0x740: mnscratch
    - NMI scratch reg
    - MRW
    - NMI's unsupported, illegal instr
- 0x741: mnepc
    - NMI PC
    - MRW
    - NMI's unsupported, illegal instr
- 0x742: mncause
    - NMI cause
    - MRW
    - NMI's unsupported, illegal instr
- 0x744: mnstatus
    - NMI status
    - MRW
    - NMI's unsupported, illegal instr

#### Counters, Timers
- 0xB00: mcycle
    - machine cycle 64-bit counter
    - MRW
    - can write to give new value to continue counting from
- 0xB02: minstret
    - machine instructions retired 64-bit counter
    - instructions retired since arbitrary time in past
    - MRW
    - can write to give new value to continue counting from
    - don't increment for instructions causing synchronous exceptions
        - ECALL, EBREAK, illegal instr, etc.
- 0xB03:0xB1F: mhpmcounter3:31
    - machine perf monitoring 64-bit counters
    - MRW
    - can write to give new value to continue counting from
    - platform-specific and ideally local to core for routing concerns
        - instrs dispatched
        - alu reg retired
        - alu imm retired
        - bru retired
        - mdu retired
        - ldu retired
        - store retired
        - amo retired
        - fence retired
        - sys retired
        - icache accesses
        - icache misses
        - itlb accesses
        - itlb misses
        - dcache accesses
        - dcache misses
        - dtlb accesses
        - dtlb misses
        - L2 cache accesses
        - L2 cache misses

#### Counter Setup
- 0x320: mcountinhibit
    - machine counter inhibit
    - MRW
    - prevent increment of associated counter
    - this one specifically 32-bit
    - {HPM[31:3], IR, 1'b0, CY}
        - CY:
            - CY = 0:
                - prevent increment of cycle
            - CY = 1:
                - cycle increment normally
        - IR:
            - IR = 0:
                - prevent increment of minstret
            - IR = 1:
                - minstret increment normally
        - HPM[31:3]:
            - HPM[i] = 0:
                - prevent increment of mhpmcounter[i]
            - HPM[i] = 1:
                - hpmcounter[i] increment normally
- 0x323:0x33F: mhpmevent3:31
    - machine perf monitoring event selector
    - MRW
    - platform-specific
        - likely not worth it to define more than 29 counters, so event selects wouldn't be used
            - especially since can use partial fields in the counters
        - if do select, CSR's essentially treated as indirect reg's
        - TBD, but likely make all read-only hardwired value

#### Debug/Trace
- 0x7A0: tselect
    - debug/trace trigger select
    - MRW
    - unratified, illegal instr
- 0x7A1: tdata1
    - debug/trace trigger data 1
    - MRW
    - unratified, illegal instr
- 0x7A2: tdata2
    - debug/trace trigger data 2
    - MRW
    - unratified, illegal instr
- 0x7A3: tdata3
    - debug/trace trigger data 3
    - MRW
    - unratified, illegal instr
- 0x7A8: mcontext
    - machine context
    - MRW
    - unratified, illegal instr

#### Debug Mode
- 0x7B0: dcsr
    - debug control and status
    - DRW
    - unratified, illegal instr
- 0x7B1: dpc
    - debug PC
    - DRW
    - unratified, illegal instr
- 0x7B2: dscratch0
    - debug scratch reg 0
    - DRW
    - unratified, illegal instr
- 0x7B3: dscratch1
    - debug scratch reg 1
    - DRW
    - unratified, illegal instr


### Supervisor CSR's
- many of these are aliased subsets of machine-mode CSR's

#### Trap Setup
- 0x100: sstatus
    - supervisor status
    - SRW
    - aliased subset of mstatus
    - {SD, WPRI[28:0], UXL[1:0], WPRI[11:0], MXR, SUM, WPRI, XS[1:0], FS[1:0], WPRI[1:0], VS[1:0], SPP, WPRI, UBE, SPIE, WPRI[3:0], SIE, WPRI}
        - SIE:
            - S-mode interrupt enable
            - enable interrupts when executing in S-mode
            - WARL
            - regardless of value, can still get interrupted by interrupts for higher privilege modes
                - S-mode execution can always be interrupted by M-mode level interrupt
                - U-mode execution can always be interrupted by M-mode or S-mode level interrupts
        - SPIE, SPP:
            - previous interrupt enable and privilege mode
            - make up two-level privilege mode stack
                - two-level in that save current and previous mode info
                - SW must be careful to maintain this stack e.g. guarantee no exceptions while saving privilege mode stack
            - SPIE:
                - S-mode previous interrupt enable
                - SIE value before this trap
                    - SW can restore SIE to this SPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - SPP:
                - S-mode previous privilege mode
                - 0: previously U-mode
                - 1: previously S-mode
                - WARL
            - HW support:
                - trap to S-mode
                    - SPIE <= SIE
                    - SIE <= 1'b0
                    - SPP <= mode trapped from
                - SRET
                    - see [Trap Return](#trap-return)
        - MXR:
            - Make Executable Readable
            - MXR = 0:
                - normal translation and protection rules where can only load from page with R=1
            - MXR = 1:
                - allow loads from pages with X=1 or R=1
            - WARL
        - SUM:
            - permit Supervisor User Memory access
            - SUM = 0:
                - S-mode load/store accesses to U=1 pages will fault
            - SUM = 1:
                - S-mode load/store accesses to U=1 pages are permitted
            - WARL
            - implies translation and protection in effect for this field to have an effect
            - S-mode instruction execute access to U=1 pages always faults
        - UBE:
            - byte endianness for DATA memory accesses
                - instruction accesses always little-endian
            - 0 for little endian, 1 for big endian
            - UBE = 1'b0:
                - U-mode Byte Endianness
                - WARL
                    - will ignore writes, only support little endian
        - FS, VS, XS, SD:
            - extension context status
                - 2 bits each for {Off, Initial, Clean, Dirty} states
            - FS[1:0]:
                - FPU state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - VS[1:0] = 2'b00:
                - Vector state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - XS[1:0] = 2'b00:
                - additional U-mode extension state encoding
                - WARL
                    - will ignore writes
            - SD:
                - SD = 0:
                    - none of FS, VS, XS dirty
                - SD = 1: 
                    - any of FS, VS, XS dirty
                - read-only
        - UXL:
            - UXL[1:0] = 2'b10:
                - UXLEN = 64
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
- 0x104: sie
    - supervisor interrupt-enable
    - SRW
    - aliased subset of mstatus
        - mie and mip have diff bits for M vs. S mode versions of interrupts, of which sie and sip can RW the S-mode versions
    - bit indexes correspond to scause bit indexes
        - following Interrupt = 1'b1
    - when interrupt into S-mode for interrupt i:
        - either:
            - executing in S-mode and sstatus.SIE = 1'b1
            - executing in U-mode
        - sip[i] = 1'b1 & sie[i] = 1'b1
        - mideleg[i] = 1'b1?
            - spec doesn't mention but seems to be implied, else would have interrupted into M-mode
    - propagate changes to sip, sie, sstatus immediately on SRET and dependent CSR writes
    - bits of supported interrupts can be written by CSR writes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIE, 3'b000, SEIE, 3'b000, STIE, 3'b000, SSIE, 1'b0}
        - LCOFIE = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts
        - SEIE:
            - S External Interrupt Enable
        - STIE:
            - S Timer Interrupt Enable
        - SSIE:
            - S Software Interrupt Enable
- 0x105: stvec
    - supervisor trap handler base address
    - SRW
    - separate from mtvec
        - need to jump to different places for M-mode traps vs. S-mode traps
        - also, S-mode using virtual memory, M-mode using baremetal
    - {BASE[63:2], MODE[1:0]}
        - BASE:
            - base address of trap PC
            - give 4-byte aligned upper 30 PC bits
            - WARL
        - MODE:
            - trap vectorization enable
            - WARL
            - MODE = 2'b00: Direct
                - all exceptions and interrupts:
                    - PC <= BASE
            - MODE = 2'b01: Vectored
                - exceptions:
                    - PC <= BASE
                - interrupts:
                    - PC <= BASE + 4 * (interrupt cause)
            - MODE = 2'b10, 2'b11:
                - reserved
                - WARL so force to 2'b00 or 2'b01 if try to write these
- 0x106: scounteren
    - supervisor counter enable
    - SRW
    - separate from mcounteren
        - this is separate control to also check for allowing access in U-mode
    - give access to aliased CSR reads for U-mode using time, instret, and hpmcounter[i] U CSR's
    - this one specifically 32-bit
    - {HPM[31:3], IR, TM, CY}
        - CY:
            - CY = 0:
                - reads to cycle by U-mode CSR instr gives illegal instr
            - CY = 1:
                - reads to cycle by U-mode CSR instr permitted if mcounteren.CY = 1, else illegal instr
        - TM:
            - TM = 0:
                - reads to time by U-mode CSR instr gives illegal instr
            - TM = 1:
                - reads to time by U-mode CSR instr permitted if mcounteren.TM = 1, else illegal instr
        - IR:
            - IR = 0:
                - reads to instret by U-mode CSR instr gives illegal instr
            - IR = 1:
                - reads to instret by U-mode CSR instr permitted if mcounteren.IR = 1, else illegal instr
        - HPM[31:3]:
            - HPM[i] = 0:
                - reads to hpmcounter[i] by U-mode CSR instr gives illegal instr
            - HPM[i] = 1:
                - reads to hpmcounter[i] by U-mode CSR instr permitted if mcounteren.HPM[i] = 1, else illegal instr
    - for S-mode, CSR read allowed if mcounteren.\<counter\>
    - for U-mode, CSR read allowed if mcounteren.\<counter\> & scounteren.\<counter\>

#### Config
- 0x10A: senvcfg
    - supervisor environment config
    - SRW
    - no senvcfgh
    - {WPRI[29:0], PMM[1:0], WPRI[23:0], CBZE, CBCFE, CBIE[1:0], WPRI[2:0], FIOM}
        - FIOM:
            - Fence of I/O implies Memory for U-mode
            - decoder OR's io + mem aq's and rl's for FENCE's
                - already treating mem and io together for AMO aq's, rl's
        - CBZE = 1'b0:
            - unratified Zicboz extension unsupported
        - {CBCFE, CBIE[1:0]} = 3'b000:
            - unratified Zicbom extension unsupported
        - PMM = 2'b00:
            - unratified Smnpm extension unsupported
    - only control FIOM, else read-only zero

#### Counter Setup
- 0x120: scountinhibit
    - supervisor counter-inhibit
    - SRW
    - unsupported
        - used by Smcdeleg Extension for counter delegation

#### Trap Handling
- 0x140: sscratch
    - scratch register for supervisor trap handlers
    - SRW
        - just read/write reg
    - separate from mscratch
        - for S mode purposes
    - typically used to store pointer to hart-local suprvisor context while hart executing in U
- 0x141: sepc
    - supervisor exception PC
    - SRW
    - separate from mepc
        - want separate exception information per execution mode
    - {sepc[63:1], 1'b0}
        - HW sets sepc[63:1] with the PC of the instruction interrupted or the instruction that raised the exception on a trap to S-mode
        - SW can freely write sepc[63:1]
- 0x142: scause
    - supervisor trap cause
    - SRW
    - separate from mcause
        - want separate exception information per execution mode
        - scause supports subset of non-M-mode bits in mcause, but should be separate hardware so that S-mode can track its own exception information
    - {Interrupt, Exception Code[62:0]}
        - Interrupt:
            - if interrupt, HW sets Interrupt = 1'b1
            - if exception, HW sets Interrupt = 1'b0
        - Exception Code[30:0]:
            - HW sets corresponding Exception Code bit
                - seems like only set highest exception: i.e. one hot
                - also seems like must cleanly order an interrupt vs. an exception since can't report both same cycle
            - Interrupt = 1:
                - [0]: Reserved = 1'b0
                - [1]: S software interrupt
                - [4:2]: Reserved = 3'b000
                - [5]: S timer interrupt
                - [8:6]: Reserved = 3'b000
                - [9]: S external interrupt
                - [12:10]: Reserved = 3'b000
                - [13]: Counter-overflow interrupt = 1'b0
                    - unsupported
                - [14:15]: Reserved = 2'b00
                - [16:63]: platform's choice = 48'h0
                    - none planned
                    - maybe [16] for power-on reset
            - Interrupt = 0:
                - [0]: instr addr misaligned = 1'b0
                    - IALIGN=16, so won't happen
                - [1]: instr access fault
                    - PMA (supported) or PMP (unsupported)
                - [2]: illegal instr
                - [3]: breakpoint
                    - EBREAK
                - [4]: load addr misaligned
                    - need for LR.W misaligned
                - [5]: load access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [6]: store/amo addr misaligned
                    - need for SC.W, AMO*.W misaligned
                - [7]: store/amo access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [8]: ECALL from U-mode
                - [9]: ECALL from S-mode
                - [11:10]: Reserved = 2'b00
                - [12]: instr page fault
                - [13]: load page fault
                    - includes LR.W
                - [14]: Reserved = 1'b0
                - [15]: store/amo page fault
                - [16:17]: Reserved = 2'b00
                - [18]: software check = 1'b0
                    - no extension present which would raise this
                        - e.g. for Spectre/Meltdown check
                - [19]: hardware error
                    - can use for unrecoverable fetch fault or other hardware bug detections
                - [20:23]: Reserved = 4'b0000
                - [24:31]: custom extensions = 8'h0
                - [32:47]: Reserved = 16'h0
                - [48:63]: custom extensions = 16'h0
    - HW sets on trap into S-mode
- 0x143: stval
    - supervisor bad address or instruction
    - SRW
    - HW sets on all traps to S-mode
        - bad address exceptions:
            - breakpoint, addr misaligned, PMA or PMP access fault, or page fault
            - set to virtual address
                - PC for bad fetch addr
                - load/store/amo address for bad dmem access 
                    - only have this after dtlb lookup and no later, wouldn't want to complete instr anyway, so give ldu/stamofu page fault immediately after dtlb lookup
        - illegal instr:
            - write zero-extended instruction
                - uncompressed should follow {32'h0, instr[31:0]}
                - compressed should follow {48'h0, instr[15:0]}
        - else: 
            - write 64'h0
    - SW can freely write
- 0x144: sip
    - supervisor interrupt pending
        - use this reg to give indication of existent interrupt
            - i.e. use these actual reg bits to determine if interrupt core
    - SRW
    - aliased subset of mstatus
        - mie and mip have diff bits for M vs. S mode versions of interrupts, of which sie and sip can RW the S-mode versions
    - bit indexes correspond to scause bit indexes
    - bits of unsupported interrupts are read-only zero
    - only lower 16-bits standard
        - only these will be implemented
    - {2'b00, LCOFIP, 3'b000, SEIP, 3'b000, STIP, 3'b000, SSIP, 1'b0}
        - LCOFIP = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts for mhpmevent[i] counters
        - SEIP:
            - S External Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by PLIC
        - STIP:
            - S Timer Interrupt Pending
            - read-only by CSR instr's
                - M-mode will get MTIP trap, take care of timer details, then write STIP with CSR instr so S mode can get timer interrupt
        - SSIP:
            - S Software Interrupt Pending
            - writable by CSR instr's
                - probably so S-mode can clear self since S mode will not be touching IPI MMCSR's
                - self S-mode signal also possible since can set as well
            - also set by IPI MMCSR's
                - not cleared since that's M-mode's job to use IPI MMCSR's?
    - priority:
        - SEI > SSI > STI > LCOFI
    - see sie ^ for remaining semantics
- 0xDA0: scountovf
    - supervisor count overflow
    - unsupported
    - would be used for Sscofpmf extension for counter overflow diagnostics

#### VM
- 0x180: satp
    - supervisor address translation and protection
    - SRW
    - unique to S-mode
        - no M-mode copy nor alias
    - PTBR + ASID
    - {MODE[3:0], ASID[15:0], PPN[43:0]}
        - MODE:
            - MODE = 4'b0000:
                - "Bare" mode
                - PA = VA
                    - zero-extended
                - SW's job to write rest of reg to 0's
                - HW ignores rest of reg
            - MODE = 4'b1000:
                - "Sv39" mode
                - VM enabled
            - relevant when satp "active" -> executing in S-mode or U-mode
        - ASID:
            - Address Space ID
            - full WARL
        - PPN:
            - PPN of page table for this context
            - essentially PTBR
            - full WARL
    - satp updates don't perform any ordering or synchronization of page table updates
        - this is SFENCE.VMA's job
        - not strictly necessary on some context switches, and as such SFENCE.VMA can be skipped, so performance will improve


#### Debug/Trace
- 0x5A8: scontext
    - supervisor context
    - SRW
    - unratified, illegal instr

#### State Enable
- 0x10C:0x10F: sstateen0:3
    - supervisor state enables
    - SRW
    - for Smstateen extension
    - unsupported, illegal instr


### User CSR's

#### FPU
- 0x001: fflags
    - FPU accrued exceptions
    - URW
    - {Reserved[58:0], NV, DZ, OF, UF, NX}
        - NX
            - Inexact
        - UF
            - Underflow
        - OF
            - Overflow
        - DZ
            - Divide by Zero
        - NV
            - Invalid Operation
        - Reserved[58:0] = 59'h0
    - can access with FRFLAGS, FSFLAGS pseudoinstructions
- 0x002: frm
    - FPU dynamic rounding mode
    - URW
    - {Reserved[60:0], RM[2:0]}
        - RM[2:0]
            - dynamic rounding mode
            - RM = 3'b000:
                - RNE: Round to Nearest Even
            - RM = 3'b001:
                - RTZ: Round towards Zero
            - RM = 3'b010:
                - RDN: Round Down towards -inf
            - RM = 3'b011:
                - RUP: Round Up towards +inf
            - RM = 3'b100:
                - RMM: Round to Nearest, ties to Max Magnitude
            - RM = 3'b101:
                - Reserved
            - RM = 3'b110:
                - Reserved
            - RM = 3'b111:
                - DYN: Dynamic Rounding Mode 
                    - if in rm of instr: use dynamic rounding mode in fcsr.RM / frm.RM
                    - if in fcsr.RM / frm.RM: Reserved
        - Reserved[60:0] = 61'h0
    - can access with FRRM, FSRM pseudoinstructions
- 0x003: fcsr
    - FPU control and status register
        - superset of equivalent bits when read fflags, frm individually
    - URW
    - {Reserved[55:0], RM[2:0], NV, DZ, OF, UF, NX}
        - NX
            - inexact
        - UF
            - underflow
        - OF
            - overflow
        - DZ
            - divide by zero
        - NV
            - invalid operation
        - RM[2:0]
            - dynamic rounding mode
            - RM = 3'b000:
                - RNE: Round to Nearest Even
            - RM = 3'b001:
                - RTZ: Round towards Zero
            - RM = 3'b010:
                - RDN: Round Down towards -inf
            - RM = 3'b011:
                - RUP: Round Up towards +inf
            - RM = 3'b100:
                - RMM: Round to Nearest, ties to Max Magnitude
            - RM = 3'b101:
                - Reserved
            - RM = 3'b110:
                - Reserved
            - RM = 3'b111:
                - DYN: Dynamic Rounding Mode 
                    - if in rm of instr: use dynamic rounding mode in fcsr.RM / frm.RM
                    - if in fcsr.RM / frm.RM: Reserved
        - Reserved[55:0] = 56'h0
    - can access with FRCSR, FSCSR pseudoinstructions

#### Counters, Timers
- 0xC00: cycle
    - user cycle counter
    - cycles since arbitrary time in past
    - URO
    - alias to mcycle
    - can access with RDCYCLE pseudoinstruction
- 0xC01: time
    - user time
    - real time since arbitrary time in past
    - tick at reasonable rate
        - when implement real time clock, probably some multiple of seconds or milliseconds or microseconds
    - URO
    - alias to read of mtime MMCSR
    - can access with RDTIME pseudoinstruction
- 0xC02: instret
    - user instructions retired
    - instructions retired since arbitrary time in past
    - URO
    - don't increment for instructions causing synchronous exceptions
        - ECALL, EBREAK, illegal instr, etc.
    - alias to minstret
    - can access with RDINSTRET pseudoinstruction
- 0xC03:0xC1F: hpmcounter3:31
    - perf monitoring counters
    - URO
    - alias to mhpmcounter3:31


## MMCSR's
- memory-mapped CSR's
- platform defined

### Machine MMCSR's
- machine-level memory-mapped CSR's 

#### Machine Timer Registers
- mtime
    - 64-bit timer
        - since RV32I, use 2x reads
    - RW
        - SW can reset value
        - HW, timer module only determines count-up
- mtimecmp
    - 64-bit timer compare
    - give Machine Timer Interrupt when (mtime > mtimecmp)
    - clear Machine Timer Interrupt when (mtime < mtimecomp) 
    - RW
        - SW can reset value
        - SW's job to set lower 32b and upper 32b such that don't get spurious interrupt while changing the value

#### Inter-Processor Interrupt Registers
- TODO
